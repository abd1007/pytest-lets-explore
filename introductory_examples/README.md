The first example
---

Pytest is run by commanding `pytest` in your shell. To run one of these
scripts, you will need to pass it as an argument to pytest. For example, if you
want to test `trivial_mathematics.py`, which contains a function to check
whether or not a value is grater than zero, you would run `pytest
trivial_mathematics.py`. Pytest will import that file, then run all tests that
it finds (in general, functions and classes with `test` in their handle). The
output of pytest will look something like this:

```
$ pytest trivial_mathematics.py
============================ test session starts ==============================
<snip>
collected 1 items

trivial_mathematics.py F

================================== FAILURES ===================================
___________________________ test_greater_than_zero ____________________________

    def test_greater_than_zero():
        assert greater_than_zero(5) is True
        assert greater_than_zero(2) is True
        assert greater_than_zero(-1) is False
>       assert greater_than_zero(0) is False
E       assert True is False
E        +  where True = greater_than_zero(0)

trivial_mathematics.py:9: AssertionError
========================== 1 failed in 0.04 seconds ===========================
```

In this example, `pytest` has imported `trivial_mathematics.py`, has found the
`test_greater_than_zero` function, and has run it. The result is that the
fourth assertion has failed. In Python, `assert` raises an `AssertionError`
when its predicate (condition) has not been met, but pytest expands this
assertion and provides additional information. It has shown that
`greater_than_zero(0)` has returned `True`, as opposed to the `False` that was
expected, showing that the function `greater_than_zero` does not function as
expected.

The script `trivial_mathematics_fixed.py` is the fixed version of this
script. When run with `pytest trivial_mathematics_fixed.py`, it prints:

```
$ pytest trivial_mathematics_fixed.py
============================ test session starts ==============================
<snip>
collected 1 items

trivial_mathematics_fixed.py .

========================== 1 passed in 0.01 seconds ===========================
```

Defining many tests
---

The script `binary_converter.py` defines a function to convert a decimal
number, such as one might read from a sensor, into a binary form which may be
more useful. It's often useful to test software under multiple conditions, so
it is useful to define multiple tests. The `binary_converter.py` script defines
two tests: `test_my_converter` and `test_even_more`. This is the result when
executed:

```
$ pytest binary_converter.py
============================= test session starts =============================
<snip>
collected 2 items

binary_converter.py .F

================================== FAILURES ===================================
_______________________________ test_even_more ________________________________

    def test_even_more():
>       assert convert_integer_to_binary_string(191, 0) == "11111111"
E       assert '10111111' == '11111111'
E         - 10111111
E         ? --
E         + 11111111
E         ?       ++

binary_converter.py:14: AssertionError
===================== 1 failed, 1 passed in 0.08 seconds ======================
```

Each `.` after `binary_converter.py` in the output denotes a passing test,
whereas an `F` denotes a failing test. More verbose output is often useful, and
can be generated by adding the `--verbose` flag like so:

```
$ pytest binary_converter.py --verbose
============================= test session starts =============================
<snip>
collected 2 items

binary_converter.py::test_my_converter PASSED
binary_converter.py::test_even_more FAILED

================================== FAILURES ===================================
_______________________________ test_even_more ________________________________

    def test_even_more():
>       assert convert_integer_to_binary_string(191, 0) == "11111111"
E       assert '10111111' == '11111111'
E         - 10111111
E         ? --
E         + 11111111
E         ?       ++

binary_converter.py:14: AssertionError
===================== 1 failed, 1 passed in 0.04 seconds ======================
```

While it's possible to define multiple tests in this way, there are issues with
this method; the second test in `test_even_more` has not even been executed,
and defining separate function for every test duplicates code, which makes
maintenance more difficult. We require a mechanism for defining a series of
similar tests in pytest Fortunately, pytest has a parameterisation mechanism,
explored in example 2.
